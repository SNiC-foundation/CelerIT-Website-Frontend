//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/api";
    }

    /**
     * @return Ok
     */
    getAllActivities(): Promise<ActivityResponse[]> {
        let url_ = this.baseUrl + "/activity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllActivities(_response);
        });
    }

    protected processGetAllActivities(response: Response): Promise<ActivityResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActivityResponse[]>(null as any);
    }

    /**
     * @param body Parameters to create activity with
     * @return Ok
     */
    createActivity(body: ActivityParams): Promise<Activity> {
        let url_ = this.baseUrl + "/activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateActivity(_response);
        });
    }

    protected processCreateActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Activity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }

    /**
     * @param id ID of activity to retrieve
     * @return Ok
     */
    getActivity(id: number): Promise<Activity> {
        let url_ = this.baseUrl + "/activity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivity(_response);
        });
    }

    protected processGetActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Activity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }

    /**
     * @param id ID of activity to update
     * @param body Update subset of parameter of activity
     * @return Ok
     */
    updateActivity(id: number, body: ActivityParams): Promise<Activity> {
        let url_ = this.baseUrl + "/activity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateActivity(_response);
        });
    }

    protected processUpdateActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Activity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }

    /**
     * @param id ID of the activity to delete
     * @return No content
     */
    deleteActivity(id: number): Promise<void> {
        let url_ = this.baseUrl + "/activity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteActivity(_response);
        });
    }

    protected processDeleteActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No content
     */
    subscribeToActivity(id: number): Promise<void> {
        let url_ = this.baseUrl + "/activity/{id}/subscribe";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscribeToActivity(_response);
        });
    }

    protected processSubscribeToActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No content
     */
    subscribeRemainingUsers(): Promise<void> {
        let url_ = this.baseUrl + "/activity/subscribe/fill";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscribeRemainingUsers(_response);
        });
    }

    protected processSubscribeRemainingUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body Parameters to create user with
     * @return Ok
     */
    registerUser(body: RegisterUserParams): Promise<User> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterUser(_response);
        });
    }

    protected processRegisterUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @return No content
     */
    forgotPassword(body: ForgotPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No content
     */
    resetPassword(body: ResetPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getProfile(): Promise<User | null> {
        let url_ = this.baseUrl + "/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfile(_response);
        });
    }

    protected processGetProfile(response: Response): Promise<User | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? User.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User | null>(null as any);
    }

    /**
     * @return No content
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllParticipants(): Promise<Participant[]> {
        let url_ = this.baseUrl + "/participant";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllParticipants(_response);
        });
    }

    protected processGetAllParticipants(response: Response): Promise<Participant[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Participant.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Participant[]>(null as any);
    }

    /**
     * @param body Parameters to create participant with
     * @return Ok
     */
    createParticipant(body: CreateParticipantParams): Promise<Participant> {
        let url_ = this.baseUrl + "/participant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateParticipant(_response);
        });
    }

    protected processCreateParticipant(response: Response): Promise<Participant> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Participant.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Participant>(null as any);
    }

    /**
     * @param id ID of participant to retrieve
     * @return Ok
     */
    getParticipant(id: number): Promise<Participant> {
        let url_ = this.baseUrl + "/participant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetParticipant(_response);
        });
    }

    protected processGetParticipant(response: Response): Promise<Participant> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Participant.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Participant>(null as any);
    }

    /**
     * @param id ID of participant to update
     * @param body Update subset of parameter of participant
     * @return Ok
     */
    updateParticipant(id: number, body: Partial_UpdateParticipantParams_): Promise<Participant> {
        let url_ = this.baseUrl + "/participant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateParticipant(_response);
        });
    }

    protected processUpdateParticipant(response: Response): Promise<Participant> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Participant.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Participant>(null as any);
    }

    /**
     * @param id ID of the participant to delete
     * @return No content
     */
    deleteParticipant(id: number): Promise<void> {
        let url_ = this.baseUrl + "/participant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteParticipant(_response);
        });
    }

    protected processDeleteParticipant(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of the participant to encrypt
     * @return Ok
     */
    getEncryptedParticipantId(id: number): Promise<string> {
        let url_ = this.baseUrl + "/participant/{id}/qrcode";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEncryptedParticipantId(_response);
        });
    }

    protected processGetEncryptedParticipantId(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Ok
     */
    getParticipantsExport(): Promise<ParticipantExport[]> {
        let url_ = this.baseUrl + "/participant/export/export";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetParticipantsExport(_response);
        });
    }

    protected processGetParticipantsExport(response: Response): Promise<ParticipantExport[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ParticipantExport.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParticipantExport[]>(null as any);
    }

    /**
     * @return No content
     */
    getParticipantQrCodeExport(): Promise<void> {
        let url_ = this.baseUrl + "/participant/export/qrcodes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetParticipantQrCodeExport(_response);
        });
    }

    protected processGetParticipantQrCodeExport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllPartners(): Promise<Partner[]> {
        let url_ = this.baseUrl + "/partner";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPartners(_response);
        });
    }

    protected processGetAllPartners(response: Response): Promise<Partner[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Partner.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Partner[]>(null as any);
    }

    /**
     * @param body Parameters to create partner with
     * @return Ok
     */
    createPartner(body: PartnerParams): Promise<Partner> {
        let url_ = this.baseUrl + "/partner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePartner(_response);
        });
    }

    protected processCreatePartner(response: Response): Promise<Partner> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Partner.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Partner>(null as any);
    }

    /**
     * @param id ID of partner to retrieve
     * @return Ok
     */
    getPartner(id: number): Promise<Partner> {
        let url_ = this.baseUrl + "/partner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPartner(_response);
        });
    }

    protected processGetPartner(response: Response): Promise<Partner> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Partner.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Partner>(null as any);
    }

    /**
     * @param id ID of partner to update
     * @param body Update subset of parameter of partner
     * @return Ok
     */
    updatePartner(id: number, body: Partial_PartnerParams_): Promise<Partner> {
        let url_ = this.baseUrl + "/partner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePartner(_response);
        });
    }

    protected processUpdatePartner(response: Response): Promise<Partner> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Partner.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Partner>(null as any);
    }

    /**
     * @param id ID of the partner to delete
     * @return No content
     */
    deletePartner(id: number): Promise<void> {
        let url_ = this.baseUrl + "/partner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePartner(_response);
        });
    }

    protected processDeletePartner(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param logo (optional) 
     * @return No content
     */
    uploadPartnerLogo(id: number, logo: FileParameter | undefined): Promise<void> {
        let url_ = this.baseUrl + "/partner/{id}/logo";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (logo === null || logo === undefined)
            throw new Error("The parameter 'logo' cannot be null.");
        else
            content_.append("logo", logo.data, logo.fileName ? logo.fileName : "logo");

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadPartnerLogo(_response);
        });
    }

    protected processUploadPartnerLogo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No content
     */
    requestScan(id: number, body: QRParams): Promise<void> {
        let url_ = this.baseUrl + "/partner/{id}/scanqr";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestScan(_response);
        });
    }

    protected processRequestScan(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllProgramParts(): Promise<ProgramPart[]> {
        let url_ = this.baseUrl + "/programpart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProgramParts(_response);
        });
    }

    protected processGetAllProgramParts(response: Response): Promise<ProgramPart[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgramPart.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramPart[]>(null as any);
    }

    /**
     * @param body Parameters to create programPart with
     * @return Ok
     */
    createProgramPart(body: ProgramPartParams): Promise<ProgramPart> {
        let url_ = this.baseUrl + "/programpart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProgramPart(_response);
        });
    }

    protected processCreateProgramPart(response: Response): Promise<ProgramPart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramPart.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramPart>(null as any);
    }

    /**
     * @param id ID of programPart to retrieve
     * @return Ok
     */
    getProgramPart(id: number): Promise<ProgramPart> {
        let url_ = this.baseUrl + "/programpart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProgramPart(_response);
        });
    }

    protected processGetProgramPart(response: Response): Promise<ProgramPart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramPart.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramPart>(null as any);
    }

    /**
     * @param id ID of programPart to update
     * @param body Update subset of parameter of programPart
     * @return Ok
     */
    updateProgramPart(id: number, body: Partial_ProgramPartParams_): Promise<ProgramPart> {
        let url_ = this.baseUrl + "/programpart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProgramPart(_response);
        });
    }

    protected processUpdateProgramPart(response: Response): Promise<ProgramPart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramPart.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramPart>(null as any);
    }

    /**
     * @param id ID of the programPart to delete
     * @return No content
     */
    deleteProgramPart(id: number): Promise<void> {
        let url_ = this.baseUrl + "/programpart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProgramPart(_response);
        });
    }

    protected processDeleteProgramPart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllRoles(): Promise<Role[]> {
        let url_ = this.baseUrl + "/role";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRoles(_response);
        });
    }

    protected processGetAllRoles(response: Response): Promise<Role[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role[]>(null as any);
    }

    /**
     * @param body Parameters to create role with
     * @return Ok
     */
    createRole(body: RoleParams): Promise<Role> {
        let url_ = this.baseUrl + "/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * @param id ID of role to retrieve
     * @return Ok
     */
    getRole(id: number): Promise<Role> {
        let url_ = this.baseUrl + "/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRole(_response);
        });
    }

    protected processGetRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * @param id ID of role to update
     * @param body Update subset of parameter of role
     * @return Ok
     */
    updateRole(id: number, body: Partial_RoleParams_): Promise<Role> {
        let url_ = this.baseUrl + "/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * @param id ID of the role to delete
     * @return No content
     */
    deleteRole(id: number): Promise<void> {
        let url_ = this.baseUrl + "/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    ping(): Promise<string> {
        let url_ = this.baseUrl + "/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPing(_response);
        });
    }

    protected processPing(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param activities (optional) 
     * @return Ok
     */
    getAllSpeakers(activities: boolean | undefined): Promise<Speaker[]> {
        let url_ = this.baseUrl + "/speaker?";
        if (activities === null)
            throw new Error("The parameter 'activities' cannot be null.");
        else if (activities !== undefined)
            url_ += "activities=" + encodeURIComponent("" + activities) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSpeakers(_response);
        });
    }

    protected processGetAllSpeakers(response: Response): Promise<Speaker[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Speaker.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Speaker[]>(null as any);
    }

    /**
     * @param body Parameters to create speaker with
     * @return Ok
     */
    createSpeaker(body: SpeakerParams): Promise<Speaker> {
        let url_ = this.baseUrl + "/speaker";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSpeaker(_response);
        });
    }

    protected processCreateSpeaker(response: Response): Promise<Speaker> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Speaker.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Speaker>(null as any);
    }

    /**
     * @param id ID of speaker to retrieve
     * @param activities (optional) 
     * @return Ok
     */
    getSpeaker(id: number, activities: boolean | undefined): Promise<Speaker> {
        let url_ = this.baseUrl + "/speaker/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activities === null)
            throw new Error("The parameter 'activities' cannot be null.");
        else if (activities !== undefined)
            url_ += "activities=" + encodeURIComponent("" + activities) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpeaker(_response);
        });
    }

    protected processGetSpeaker(response: Response): Promise<Speaker> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Speaker.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Speaker>(null as any);
    }

    /**
     * @param id ID of speaker to update
     * @param body Update subset of parameter of speaker
     * @return Ok
     */
    updateSpeaker(id: number, body: Partial_SpeakerParams_): Promise<Speaker> {
        let url_ = this.baseUrl + "/speaker/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSpeaker(_response);
        });
    }

    protected processUpdateSpeaker(response: Response): Promise<Speaker> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Speaker.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Speaker>(null as any);
    }

    /**
     * @param id ID of the speaker to delete
     * @return No content
     */
    deleteSpeaker(id: number): Promise<void> {
        let url_ = this.baseUrl + "/speaker/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSpeaker(_response);
        });
    }

    protected processDeleteSpeaker(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param logo (optional) 
     * @return No content
     */
    uploadSpeakerImage(id: number, logo: FileParameter | undefined): Promise<void> {
        let url_ = this.baseUrl + "/speaker/{id}/image";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (logo === null || logo === undefined)
            throw new Error("The parameter 'logo' cannot be null.");
        else
            content_.append("logo", logo.data, logo.fileName ? logo.fileName : "logo");

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadSpeakerImage(_response);
        });
    }

    protected processUploadSpeakerImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllSubscribeActivities(): Promise<SubscribeActivity[]> {
        let url_ = this.baseUrl + "/subscribeActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSubscribeActivities(_response);
        });
    }

    protected processGetAllSubscribeActivities(response: Response): Promise<SubscribeActivity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribeActivity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubscribeActivity[]>(null as any);
    }

    /**
     * @param body Parameters to create subscribeActivity with
     * @return Ok
     */
    createSubscribeActivity(body: CreateSubscribeActivityParams): Promise<SubscribeActivity> {
        let url_ = this.baseUrl + "/subscribeActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSubscribeActivity(_response);
        });
    }

    protected processCreateSubscribeActivity(response: Response): Promise<SubscribeActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscribeActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubscribeActivity>(null as any);
    }

    /**
     * @param id ID of subscribeActivity to retrieve
     * @return Ok
     */
    getSubscribeActivity(id: number): Promise<SubscribeActivity> {
        let url_ = this.baseUrl + "/subscribeActivity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSubscribeActivity(_response);
        });
    }

    protected processGetSubscribeActivity(response: Response): Promise<SubscribeActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscribeActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubscribeActivity>(null as any);
    }

    /**
     * @param id ID of subscribeActivity to update
     * @param body Update subset of parameter of subscribeActivity
     * @return Ok
     */
    updateSubscribeActivity(id: number, body: Partial_UpdateSubscribeActivityParams_): Promise<SubscribeActivity> {
        let url_ = this.baseUrl + "/subscribeActivity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSubscribeActivity(_response);
        });
    }

    protected processUpdateSubscribeActivity(response: Response): Promise<SubscribeActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscribeActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubscribeActivity>(null as any);
    }

    /**
     * @param id ID of the subscribeActivity to delete
     * @return No content
     */
    deleteSubscribeActivity(id: number): Promise<void> {
        let url_ = this.baseUrl + "/subscribeActivity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSubscribeActivity(_response);
        });
    }

    protected processDeleteSubscribeActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param claimed (optional) 
     * @param association (optional) 
     * @return Ok
     */
    getAllTickets(claimed: boolean | undefined, association: string | undefined): Promise<Ticket[]> {
        let url_ = this.baseUrl + "/ticket?";
        if (claimed === null)
            throw new Error("The parameter 'claimed' cannot be null.");
        else if (claimed !== undefined)
            url_ += "claimed=" + encodeURIComponent("" + claimed) + "&";
        if (association === null)
            throw new Error("The parameter 'association' cannot be null.");
        else if (association !== undefined)
            url_ += "association=" + encodeURIComponent("" + association) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTickets(_response);
        });
    }

    protected processGetAllTickets(response: Response): Promise<Ticket[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Ticket.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Ticket[]>(null as any);
    }

    /**
     * @param body Parameters to create tickets with
     * @return Ok
     */
    createTicket(body: CreateTicketPrams): Promise<Ticket[]> {
        let url_ = this.baseUrl + "/ticket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTicket(_response);
        });
    }

    protected processCreateTicket(response: Response): Promise<Ticket[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Ticket.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Ticket[]>(null as any);
    }

    /**
     * @return Ok
     */
    getSingleTicket(code: string): Promise<Ticket | null> {
        let url_ = this.baseUrl + "/ticket/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSingleTicket(_response);
        });
    }

    protected processGetSingleTicket(response: Response): Promise<Ticket | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Ticket.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Ticket | null>(null as any);
    }

    /**
     * @return Ok
     */
    scanSingleTicket(code: string): Promise<Ticket | null> {
        let url_ = this.baseUrl + "/ticket/{code}/scan";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScanSingleTicket(_response);
        });
    }

    protected processScanSingleTicket(response: Response): Promise<Ticket | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Ticket.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Ticket | null>(null as any);
    }

    /**
     * @param id ID of the user to delete
     * @return No content
     */
    deleteTicket(id: number): Promise<void> {
        let url_ = this.baseUrl + "/ticket/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTicket(_response);
        });
    }

    protected processDeleteTicket(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllUsers(): Promise<User[]> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: Response): Promise<User[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User[]>(null as any);
    }

    /**
     * @param body Parameters to create user with
     * @return Ok
     */
    createUser(body: UserParams): Promise<User> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of user to retrieve
     * @return Ok
     */
    getUser(id: number): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of user to update
     * @param body Update subset of parameter of user
     * @return Ok
     */
    updateUser(id: number, body: Partial_UserParams_): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of the user to delete
     * @return No content
     */
    deleteUser(id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of user to update
     * @param body Update subset of parameter of user
     * @return Ok
     */
    updateUserProfile(id: number, body: Partial_PersonalUserParams_): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}/profile";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserProfile(_response);
        });
    }

    protected processUpdateUserProfile(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of user to update
     * @param body IDs of all roles this user should have
     * @return Ok
     */
    updateUserRoles(id: number, body: number[]): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserRoles(_response);
        });
    }

    protected processUpdateUserRoles(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param date User creation date for which people should receive an email
     * @return Ok
     */
    getSetPasswordReminderUsers(date: Date): Promise<User[]> {
        let url_ = this.baseUrl + "/user/mail/set-password-reminder?";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSetPasswordReminderUsers(_response);
        });
    }

    protected processGetSetPasswordReminderUsers(response: Response): Promise<User[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User[]>(null as any);
    }

    /**
     * @return No content
     */
    sendSetPasswordReminder(body: SendSetPasswordReminderParams): Promise<void> {
        let url_ = this.baseUrl + "/user/mail/set-password-reminder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendSetPasswordReminder(_response);
        });
    }

    protected processSendSetPasswordReminder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getTracksReminderUsers(): Promise<User[]> {
        let url_ = this.baseUrl + "/user/mail/tracks-reminder";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTracksReminderUsers(_response);
        });
    }

    protected processGetTracksReminderUsers(response: Response): Promise<User[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User[]>(null as any);
    }

    /**
     * @return No content
     */
    sendTracksReminders(body: number[]): Promise<void> {
        let url_ = this.baseUrl + "/user/mail/tracks-reminder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendTracksReminders(_response);
        });
    }

    protected processSendTracksReminders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No content
     */
    sendFinalInfo(): Promise<void> {
        let url_ = this.baseUrl + "/user/mail/final-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendFinalInfo(_response);
        });
    }

    protected processSendFinalInfo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    login(body: LoginParams): Promise<void> {
        let url_ = this.baseUrl + "/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Activity implements IActivity {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    name!: string;
    location!: string;
    programPartId!: number;
    programPart!: ProgramPart;
    description?: string | undefined;
    recordingUrl?: string;
    speakers!: Speaker[];
    subscribe?: SubscribeActivity | undefined;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.programPart = new ProgramPart();
            this.speakers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.programPartId = _data["programPartId"];
            this.programPart = _data["programPart"] ? ProgramPart.fromJS(_data["programPart"]) : new ProgramPart();
            this.description = _data["description"];
            this.recordingUrl = _data["recordingUrl"];
            if (Array.isArray(_data["speakers"])) {
                this.speakers = [] as any;
                for (let item of _data["speakers"])
                    this.speakers!.push(Speaker.fromJS(item));
            }
            this.subscribe = _data["subscribe"] ? SubscribeActivity.fromJS(_data["subscribe"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["location"] = this.location;
        data["programPartId"] = this.programPartId;
        data["programPart"] = this.programPart ? this.programPart.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["recordingUrl"] = this.recordingUrl;
        if (Array.isArray(this.speakers)) {
            data["speakers"] = [];
            for (let item of this.speakers)
                data["speakers"].push(item.toJSON());
        }
        data["subscribe"] = this.subscribe ? this.subscribe.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActivity {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    name: string;
    location: string;
    programPartId: number;
    programPart: ProgramPart;
    description?: string | undefined;
    recordingUrl?: string;
    speakers: Speaker[];
    subscribe?: SubscribeActivity | undefined;
}

export class ProgramPart implements IProgramPart {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    name!: string;
    beginTime!: Date;
    endTime!: Date;
    activities!: Activity[];

    constructor(data?: IProgramPart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(Activity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgramPart {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramPart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProgramPart {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    name: string;
    beginTime: Date;
    endTime: Date;
    activities: Activity[];
}

export class Speaker implements ISpeaker {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    name!: string;
    description!: string;
    activities!: Activity[];
    imageFilename?: string;

    constructor(data?: ISpeaker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(Activity.fromJS(item));
            }
            this.imageFilename = _data["imageFilename"];
        }
    }

    static fromJS(data: any): Speaker {
        data = typeof data === 'object' ? data : {};
        let result = new Speaker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        data["imageFilename"] = this.imageFilename;
        return data;
    }
}

export interface ISpeaker {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    name: string;
    description: string;
    activities: Activity[];
    imageFilename?: string;
}

export class User implements IUser {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    email!: string;
    name!: string;
    emailVerified!: boolean;
    dietaryWishes!: string;
    agreeToPrivacyPolicy!: boolean;
    participantInfo?: Participant;
    roles!: Role[];
    ticket?: Ticket;
    partnerId?: number | undefined;
    partner?: Partner | undefined;
    subscriptions!: SubscribeActivity[];
    scans!: TicketScan[];
    identity?: LocalAuthenticator;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
            this.subscriptions = [];
            this.scans = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.emailVerified = _data["emailVerified"];
            this.dietaryWishes = _data["dietaryWishes"];
            this.agreeToPrivacyPolicy = _data["agreeToPrivacyPolicy"];
            this.participantInfo = _data["participantInfo"] ? Participant.fromJS(_data["participantInfo"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
            this.ticket = _data["ticket"] ? Ticket.fromJS(_data["ticket"]) : <any>undefined;
            this.partnerId = _data["partnerId"];
            this.partner = _data["partner"] ? Partner.fromJS(_data["partner"]) : <any>undefined;
            if (Array.isArray(_data["subscriptions"])) {
                this.subscriptions = [] as any;
                for (let item of _data["subscriptions"])
                    this.subscriptions!.push(SubscribeActivity.fromJS(item));
            }
            if (Array.isArray(_data["scans"])) {
                this.scans = [] as any;
                for (let item of _data["scans"])
                    this.scans!.push(TicketScan.fromJS(item));
            }
            this.identity = _data["identity"] ? LocalAuthenticator.fromJS(_data["identity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["email"] = this.email;
        data["name"] = this.name;
        data["emailVerified"] = this.emailVerified;
        data["dietaryWishes"] = this.dietaryWishes;
        data["agreeToPrivacyPolicy"] = this.agreeToPrivacyPolicy;
        data["participantInfo"] = this.participantInfo ? this.participantInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["partnerId"] = this.partnerId;
        data["partner"] = this.partner ? this.partner.toJSON() : <any>undefined;
        if (Array.isArray(this.subscriptions)) {
            data["subscriptions"] = [];
            for (let item of this.subscriptions)
                data["subscriptions"].push(item.toJSON());
        }
        if (Array.isArray(this.scans)) {
            data["scans"] = [];
            for (let item of this.scans)
                data["scans"].push(item.toJSON());
        }
        data["identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUser {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    email: string;
    name: string;
    emailVerified: boolean;
    dietaryWishes: string;
    agreeToPrivacyPolicy: boolean;
    participantInfo?: Participant;
    roles: Role[];
    ticket?: Ticket;
    partnerId?: number | undefined;
    partner?: Partner | undefined;
    subscriptions: SubscribeActivity[];
    scans: TicketScan[];
    identity?: LocalAuthenticator;
}

export class Participant implements IParticipant {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    userId!: number;
    user!: User;
    studyProgram!: string;

    constructor(data?: IParticipant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.studyProgram = _data["studyProgram"];
        }
    }

    static fromJS(data: any): Participant {
        data = typeof data === 'object' ? data : {};
        let result = new Participant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["studyProgram"] = this.studyProgram;
        return data;
    }
}

export interface IParticipant {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    userId: number;
    user: User;
    studyProgram: string;
}

export class Role implements IRole {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    name!: string;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        return data;
    }
}

export interface IRole {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    name: string;
}

export class Ticket implements ITicket {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    userId?: number | undefined;
    user?: User | undefined;
    association!: string;
    code!: string;
    scans!: TicketScan[];

    constructor(data?: ITicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scans = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.association = _data["association"];
            this.code = _data["code"];
            if (Array.isArray(_data["scans"])) {
                this.scans = [] as any;
                for (let item of _data["scans"])
                    this.scans!.push(TicketScan.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Ticket {
        data = typeof data === 'object' ? data : {};
        let result = new Ticket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["association"] = this.association;
        data["code"] = this.code;
        if (Array.isArray(this.scans)) {
            data["scans"] = [];
            for (let item of this.scans)
                data["scans"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITicket {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    userId?: number | undefined;
    user?: User | undefined;
    association: string;
    code: string;
    scans: TicketScan[];
}

export class TicketScan implements ITicketScan {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    ticketId!: number;
    userId!: number;
    ticket!: Ticket;
    user!: User;

    constructor(data?: ITicketScan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticket = new Ticket();
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.ticketId = _data["ticketId"];
            this.userId = _data["userId"];
            this.ticket = _data["ticket"] ? Ticket.fromJS(_data["ticket"]) : new Ticket();
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
        }
    }

    static fromJS(data: any): TicketScan {
        data = typeof data === 'object' ? data : {};
        let result = new TicketScan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["ticketId"] = this.ticketId;
        data["userId"] = this.userId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITicketScan {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    ticketId: number;
    userId: number;
    ticket: Ticket;
    user: User;
}

export enum SponsorPackage {
    Bronze = "bronze",
    Silver = "silver",
    Gold = "gold",
    Platinum = "platinum",
}

export class Partner implements IPartner {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    name!: string;
    location!: string;
    specialization!: string;
    shortDescription?: string;
    description?: string;
    url!: string;
    package!: SponsorPackage;
    logoFilename?: string;
    participants!: Participant[];

    constructor(data?: IPartner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.participants = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.specialization = _data["specialization"];
            this.shortDescription = _data["shortDescription"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.package = _data["package"];
            this.logoFilename = _data["logoFilename"];
            if (Array.isArray(_data["participants"])) {
                this.participants = [] as any;
                for (let item of _data["participants"])
                    this.participants!.push(Participant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Partner {
        data = typeof data === 'object' ? data : {};
        let result = new Partner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["location"] = this.location;
        data["specialization"] = this.specialization;
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        data["url"] = this.url;
        data["package"] = this.package;
        data["logoFilename"] = this.logoFilename;
        if (Array.isArray(this.participants)) {
            data["participants"] = [];
            for (let item of this.participants)
                data["participants"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPartner {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    name: string;
    location: string;
    specialization: string;
    shortDescription?: string;
    description?: string;
    url: string;
    package: SponsorPackage;
    logoFilename?: string;
    participants: Participant[];
}

export class SubscribeActivity implements ISubscribeActivity {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    activityId!: number;
    activity!: Activity;
    maxParticipants!: number;
    subscriptionListOpenDate!: Date;
    subscriptionListCloseDate!: Date;
    subscribers!: User[];

    constructor(data?: ISubscribeActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activity = new Activity();
            this.subscribers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : new Activity();
            this.maxParticipants = _data["maxParticipants"];
            this.subscriptionListOpenDate = _data["subscriptionListOpenDate"] ? new Date(_data["subscriptionListOpenDate"].toString()) : <any>undefined;
            this.subscriptionListCloseDate = _data["subscriptionListCloseDate"] ? new Date(_data["subscriptionListCloseDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["subscribers"])) {
                this.subscribers = [] as any;
                for (let item of _data["subscribers"])
                    this.subscribers!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscribeActivity {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribeActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["maxParticipants"] = this.maxParticipants;
        data["subscriptionListOpenDate"] = this.subscriptionListOpenDate ? this.subscriptionListOpenDate.toISOString() : <any>undefined;
        data["subscriptionListCloseDate"] = this.subscriptionListCloseDate ? this.subscriptionListCloseDate.toISOString() : <any>undefined;
        if (Array.isArray(this.subscribers)) {
            data["subscribers"] = [];
            for (let item of this.subscribers)
                data["subscribers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubscribeActivity {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    activityId: number;
    activity: Activity;
    maxParticipants: number;
    subscriptionListOpenDate: Date;
    subscriptionListCloseDate: Date;
    subscribers: User[];
}

export class LocalAuthenticator implements ILocalAuthenticator {
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    userId!: number;
    user!: User;
    verifiedEmail!: boolean;
    hash?: string;
    salt!: string;

    constructor(data?: ILocalAuthenticator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.verifiedEmail = _data["verifiedEmail"];
            this.hash = _data["hash"];
            this.salt = _data["salt"];
        }
    }

    static fromJS(data: any): LocalAuthenticator {
        data = typeof data === 'object' ? data : {};
        let result = new LocalAuthenticator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["verifiedEmail"] = this.verifiedEmail;
        data["hash"] = this.hash;
        data["salt"] = this.salt;
        return data;
    }
}

export interface ILocalAuthenticator {
    createdAt: Date;
    updatedAt: Date;
    version: number;
    userId: number;
    user: User;
    verifiedEmail: boolean;
    hash?: string;
    salt: string;
}

export class ActivityResponse implements IActivityResponse {
    activity!: Activity;
    nrOfSubscribers!: number;

    constructor(data?: IActivityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activity = new Activity();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : new Activity();
            this.nrOfSubscribers = _data["nrOfSubscribers"];
        }
    }

    static fromJS(data: any): ActivityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["nrOfSubscribers"] = this.nrOfSubscribers;
        return data;
    }
}

export interface IActivityResponse {
    activity: Activity;
    nrOfSubscribers: number;
}

export class UpdateSubscribeActivityParams implements IUpdateSubscribeActivityParams {
    maxParticipants!: number;
    subscriptionListOpenDate!: Date;
    subscriptionListCloseDate!: Date;

    constructor(data?: IUpdateSubscribeActivityParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxParticipants = _data["maxParticipants"];
            this.subscriptionListOpenDate = _data["subscriptionListOpenDate"] ? new Date(_data["subscriptionListOpenDate"].toString()) : <any>undefined;
            this.subscriptionListCloseDate = _data["subscriptionListCloseDate"] ? new Date(_data["subscriptionListCloseDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateSubscribeActivityParams {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubscribeActivityParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxParticipants"] = this.maxParticipants;
        data["subscriptionListOpenDate"] = this.subscriptionListOpenDate ? this.subscriptionListOpenDate.toISOString() : <any>undefined;
        data["subscriptionListCloseDate"] = this.subscriptionListCloseDate ? this.subscriptionListCloseDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateSubscribeActivityParams {
    maxParticipants: number;
    subscriptionListOpenDate: Date;
    subscriptionListCloseDate: Date;
}

export class ActivityParams implements IActivityParams {
    name!: string;
    location!: string;
    programPartId!: number;
    description?: string;
    recordingUrl?: string;
    image?: string;
    speakerIds?: number[];
    subscribe?: UpdateSubscribeActivityParams;

    constructor(data?: IActivityParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.programPartId = _data["programPartId"];
            this.description = _data["description"];
            this.recordingUrl = _data["recordingUrl"];
            this.image = _data["image"];
            if (Array.isArray(_data["speakerIds"])) {
                this.speakerIds = [] as any;
                for (let item of _data["speakerIds"])
                    this.speakerIds!.push(item);
            }
            this.subscribe = _data["subscribe"] ? UpdateSubscribeActivityParams.fromJS(_data["subscribe"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityParams {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["programPartId"] = this.programPartId;
        data["description"] = this.description;
        data["recordingUrl"] = this.recordingUrl;
        data["image"] = this.image;
        if (Array.isArray(this.speakerIds)) {
            data["speakerIds"] = [];
            for (let item of this.speakerIds)
                data["speakerIds"].push(item);
        }
        data["subscribe"] = this.subscribe ? this.subscribe.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActivityParams {
    name: string;
    location: string;
    programPartId: number;
    description?: string;
    recordingUrl?: string;
    image?: string;
    speakerIds?: number[];
    subscribe?: UpdateSubscribeActivityParams;
}

export class ApiError implements IApiError {
    name!: string;
    message!: string;
    stack?: string;
    /** The activity code of the error, as defined by HTTP activity codes. */
    statusCode!: number;

    constructor(data?: IApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.message = _data["message"];
            this.stack = _data["stack"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): ApiError {
        data = typeof data === 'object' ? data : {};
        let result = new ApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["message"] = this.message;
        data["stack"] = this.stack;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IApiError {
    name: string;
    message: string;
    stack?: string;
    /** The activity code of the error, as defined by HTTP activity codes. */
    statusCode: number;
}

/** WrappedApiError represents the type returned by the server. */
export class WrappedApiError implements IWrappedApiError {
    error!: ApiError;

    constructor(data?: IWrappedApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.error = new ApiError();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? ApiError.fromJS(_data["error"]) : new ApiError();
        }
    }

    static fromJS(data: any): WrappedApiError {
        data = typeof data === 'object' ? data : {};
        let result = new WrappedApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

/** WrappedApiError represents the type returned by the server. */
export interface IWrappedApiError {
    error: ApiError;
}

export class CreateParticipantUserParams implements ICreateParticipantUserParams {
    email!: string;
    name!: string;
    dietaryWishes!: string;
    agreeToPrivacyPolicy!: boolean;
    participantInfo!: ParticipantInfo;

    constructor(data?: ICreateParticipantUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.participantInfo = new ParticipantInfo();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.dietaryWishes = _data["dietaryWishes"];
            this.agreeToPrivacyPolicy = _data["agreeToPrivacyPolicy"];
            this.participantInfo = _data["participantInfo"] ? ParticipantInfo.fromJS(_data["participantInfo"]) : new ParticipantInfo();
        }
    }

    static fromJS(data: any): CreateParticipantUserParams {
        data = typeof data === 'object' ? data : {};
        let result = new CreateParticipantUserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["dietaryWishes"] = this.dietaryWishes;
        data["agreeToPrivacyPolicy"] = this.agreeToPrivacyPolicy;
        data["participantInfo"] = this.participantInfo ? this.participantInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateParticipantUserParams {
    email: string;
    name: string;
    dietaryWishes: string;
    agreeToPrivacyPolicy: boolean;
    participantInfo: ParticipantInfo;
}

export class RegisterUserParams implements IRegisterUserParams {
    user!: CreateParticipantUserParams;
    token!: string;

    constructor(data?: IRegisterUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new CreateParticipantUserParams();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? CreateParticipantUserParams.fromJS(_data["user"]) : new CreateParticipantUserParams();
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): RegisterUserParams {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["token"] = this.token;
        return data;
    }
}

export interface IRegisterUserParams {
    user: CreateParticipantUserParams;
    token: string;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email: string;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    token!: string;
    newPassword!: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    token: string;
    newPassword: string;
}

export class CreateParticipantParams implements ICreateParticipantParams {
    studyProgram!: string;
    userId!: number;

    constructor(data?: ICreateParticipantParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studyProgram = _data["studyProgram"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CreateParticipantParams {
        data = typeof data === 'object' ? data : {};
        let result = new CreateParticipantParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studyProgram"] = this.studyProgram;
        data["userId"] = this.userId;
        return data;
    }
}

export interface ICreateParticipantParams {
    studyProgram: string;
    userId: number;
}

/** Make all properties in T optional */
export class Partial_UpdateParticipantParams_ implements IPartial_UpdateParticipantParams_ {
    studyProgram?: string;

    constructor(data?: IPartial_UpdateParticipantParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studyProgram = _data["studyProgram"];
        }
    }

    static fromJS(data: any): Partial_UpdateParticipantParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_UpdateParticipantParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studyProgram"] = this.studyProgram;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_UpdateParticipantParams_ {
    studyProgram?: string;
}

export class ParticipantExport implements IParticipantExport {
    id!: number;
    ticket!: string;
    name!: string;
    studyAssociation!: string;
    studyProgram!: string;
    qrCode!: string;
    track1Name!: string;
    track1Location!: string;
    track2Name!: string;
    track2Location!: string;
    track3Name!: string;
    track3Location!: string;

    constructor(data?: IParticipantExport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ticket = _data["ticket"];
            this.name = _data["name"];
            this.studyAssociation = _data["studyAssociation"];
            this.studyProgram = _data["studyProgram"];
            this.qrCode = _data["qrCode"];
            this.track1Name = _data["track1Name"];
            this.track1Location = _data["track1Location"];
            this.track2Name = _data["track2Name"];
            this.track2Location = _data["track2Location"];
            this.track3Name = _data["track3Name"];
            this.track3Location = _data["track3Location"];
        }
    }

    static fromJS(data: any): ParticipantExport {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantExport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticket"] = this.ticket;
        data["name"] = this.name;
        data["studyAssociation"] = this.studyAssociation;
        data["studyProgram"] = this.studyProgram;
        data["qrCode"] = this.qrCode;
        data["track1Name"] = this.track1Name;
        data["track1Location"] = this.track1Location;
        data["track2Name"] = this.track2Name;
        data["track2Location"] = this.track2Location;
        data["track3Name"] = this.track3Name;
        data["track3Location"] = this.track3Location;
        return data;
    }
}

export interface IParticipantExport {
    id: number;
    ticket: string;
    name: string;
    studyAssociation: string;
    studyProgram: string;
    qrCode: string;
    track1Name: string;
    track1Location: string;
    track2Name: string;
    track2Location: string;
    track3Name: string;
    track3Location: string;
}

export class PartnerParams implements IPartnerParams {
    name!: string;
    location!: string;
    specialization!: string;
    shortDescription?: string;
    description?: string;
    url!: string;
    package!: SponsorPackage;

    constructor(data?: IPartnerParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.specialization = _data["specialization"];
            this.shortDescription = _data["shortDescription"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.package = _data["package"];
        }
    }

    static fromJS(data: any): PartnerParams {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["specialization"] = this.specialization;
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        data["url"] = this.url;
        data["package"] = this.package;
        return data;
    }
}

export interface IPartnerParams {
    name: string;
    location: string;
    specialization: string;
    shortDescription?: string;
    description?: string;
    url: string;
    package: SponsorPackage;
}

/** Make all properties in T optional */
export class Partial_PartnerParams_ implements IPartial_PartnerParams_ {
    name?: string;
    location?: string;
    specialization?: string;
    shortDescription?: string;
    description?: string;
    url?: string;
    package?: SponsorPackage;

    constructor(data?: IPartial_PartnerParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.specialization = _data["specialization"];
            this.shortDescription = _data["shortDescription"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.package = _data["package"];
        }
    }

    static fromJS(data: any): Partial_PartnerParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_PartnerParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["specialization"] = this.specialization;
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        data["url"] = this.url;
        data["package"] = this.package;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_PartnerParams_ {
    name?: string;
    location?: string;
    specialization?: string;
    shortDescription?: string;
    description?: string;
    url?: string;
    package?: SponsorPackage;
}

export class QRParams implements IQRParams {
    encryptedId!: string;

    constructor(data?: IQRParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.encryptedId = _data["encryptedId"];
        }
    }

    static fromJS(data: any): QRParams {
        data = typeof data === 'object' ? data : {};
        let result = new QRParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["encryptedId"] = this.encryptedId;
        return data;
    }
}

export interface IQRParams {
    encryptedId: string;
}

export class ProgramPartParams implements IProgramPartParams {
    name!: string;
    beginTime!: Date;
    endTime!: Date;

    constructor(data?: IProgramPartParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProgramPartParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramPartParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IProgramPartParams {
    name: string;
    beginTime: Date;
    endTime: Date;
}

/** Make all properties in T optional */
export class Partial_ProgramPartParams_ implements IPartial_ProgramPartParams_ {
    name?: string;
    beginTime?: Date;
    endTime?: Date;

    constructor(data?: IPartial_ProgramPartParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Partial_ProgramPartParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ProgramPartParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_ProgramPartParams_ {
    name?: string;
    beginTime?: Date;
    endTime?: Date;
}

export class RoleParams implements IRoleParams {
    name!: string;

    constructor(data?: IRoleParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleParams {
        data = typeof data === 'object' ? data : {};
        let result = new RoleParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IRoleParams {
    name: string;
}

/** Make all properties in T optional */
export class Partial_RoleParams_ implements IPartial_RoleParams_ {
    name?: string;

    constructor(data?: IPartial_RoleParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Partial_RoleParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_RoleParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_RoleParams_ {
    name?: string;
}

export class SpeakerParams implements ISpeakerParams {
    name!: string;
    description!: string;

    constructor(data?: ISpeakerParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SpeakerParams {
        data = typeof data === 'object' ? data : {};
        let result = new SpeakerParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ISpeakerParams {
    name: string;
    description: string;
}

/** Make all properties in T optional */
export class Partial_SpeakerParams_ implements IPartial_SpeakerParams_ {
    name?: string;
    description?: string;

    constructor(data?: IPartial_SpeakerParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Partial_SpeakerParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_SpeakerParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_SpeakerParams_ {
    name?: string;
    description?: string;
}

export class CreateSubscribeActivityParams implements ICreateSubscribeActivityParams {
    maxParticipants!: number;
    subscriptionListOpenDate!: Date;
    subscriptionListCloseDate!: Date;
    activityId!: number;

    constructor(data?: ICreateSubscribeActivityParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxParticipants = _data["maxParticipants"];
            this.subscriptionListOpenDate = _data["subscriptionListOpenDate"] ? new Date(_data["subscriptionListOpenDate"].toString()) : <any>undefined;
            this.subscriptionListCloseDate = _data["subscriptionListCloseDate"] ? new Date(_data["subscriptionListCloseDate"].toString()) : <any>undefined;
            this.activityId = _data["activityId"];
        }
    }

    static fromJS(data: any): CreateSubscribeActivityParams {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubscribeActivityParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxParticipants"] = this.maxParticipants;
        data["subscriptionListOpenDate"] = this.subscriptionListOpenDate ? this.subscriptionListOpenDate.toISOString() : <any>undefined;
        data["subscriptionListCloseDate"] = this.subscriptionListCloseDate ? this.subscriptionListCloseDate.toISOString() : <any>undefined;
        data["activityId"] = this.activityId;
        return data;
    }
}

export interface ICreateSubscribeActivityParams {
    maxParticipants: number;
    subscriptionListOpenDate: Date;
    subscriptionListCloseDate: Date;
    activityId: number;
}

/** Make all properties in T optional */
export class Partial_UpdateSubscribeActivityParams_ implements IPartial_UpdateSubscribeActivityParams_ {
    maxParticipants?: number;
    subscriptionListOpenDate?: Date;
    subscriptionListCloseDate?: Date;

    constructor(data?: IPartial_UpdateSubscribeActivityParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxParticipants = _data["maxParticipants"];
            this.subscriptionListOpenDate = _data["subscriptionListOpenDate"] ? new Date(_data["subscriptionListOpenDate"].toString()) : <any>undefined;
            this.subscriptionListCloseDate = _data["subscriptionListCloseDate"] ? new Date(_data["subscriptionListCloseDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Partial_UpdateSubscribeActivityParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_UpdateSubscribeActivityParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxParticipants"] = this.maxParticipants;
        data["subscriptionListOpenDate"] = this.subscriptionListOpenDate ? this.subscriptionListOpenDate.toISOString() : <any>undefined;
        data["subscriptionListCloseDate"] = this.subscriptionListCloseDate ? this.subscriptionListCloseDate.toISOString() : <any>undefined;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_UpdateSubscribeActivityParams_ {
    maxParticipants?: number;
    subscriptionListOpenDate?: Date;
    subscriptionListCloseDate?: Date;
}

export class CreateTicketPrams implements ICreateTicketPrams {
    association!: string;
    amount!: number;

    constructor(data?: ICreateTicketPrams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.association = _data["association"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): CreateTicketPrams {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketPrams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["association"] = this.association;
        data["amount"] = this.amount;
        return data;
    }
}

export interface ICreateTicketPrams {
    association: string;
    amount: number;
}

export class UpdateParticipantParams implements IUpdateParticipantParams {
    studyProgram!: string;

    constructor(data?: IUpdateParticipantParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studyProgram = _data["studyProgram"];
        }
    }

    static fromJS(data: any): UpdateParticipantParams {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studyProgram"] = this.studyProgram;
        return data;
    }
}

export interface IUpdateParticipantParams {
    studyProgram: string;
}

export class UserParams implements IUserParams {
    name!: string;
    dietaryWishes!: string;
    participantInfo?: UpdateParticipantParams;
    email!: string;
    agreeToPrivacyPolicy!: boolean;
    partnerId?: number | undefined;

    constructor(data?: IUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.dietaryWishes = _data["dietaryWishes"];
            this.participantInfo = _data["participantInfo"] ? UpdateParticipantParams.fromJS(_data["participantInfo"]) : <any>undefined;
            this.email = _data["email"];
            this.agreeToPrivacyPolicy = _data["agreeToPrivacyPolicy"];
            this.partnerId = _data["partnerId"];
        }
    }

    static fromJS(data: any): UserParams {
        data = typeof data === 'object' ? data : {};
        let result = new UserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dietaryWishes"] = this.dietaryWishes;
        data["participantInfo"] = this.participantInfo ? this.participantInfo.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["agreeToPrivacyPolicy"] = this.agreeToPrivacyPolicy;
        data["partnerId"] = this.partnerId;
        return data;
    }
}

export interface IUserParams {
    name: string;
    dietaryWishes: string;
    participantInfo?: UpdateParticipantParams;
    email: string;
    agreeToPrivacyPolicy: boolean;
    partnerId?: number | undefined;
}

/** Make all properties in T optional */
export class Partial_UserParams_ implements IPartial_UserParams_ {
    email?: string;
    agreeToPrivacyPolicy?: boolean;
    partnerId?: number | undefined;
    name?: string;
    dietaryWishes?: string;
    participantInfo?: UpdateParticipantParams;

    constructor(data?: IPartial_UserParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.agreeToPrivacyPolicy = _data["agreeToPrivacyPolicy"];
            this.partnerId = _data["partnerId"];
            this.name = _data["name"];
            this.dietaryWishes = _data["dietaryWishes"];
            this.participantInfo = _data["participantInfo"] ? UpdateParticipantParams.fromJS(_data["participantInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Partial_UserParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_UserParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["agreeToPrivacyPolicy"] = this.agreeToPrivacyPolicy;
        data["partnerId"] = this.partnerId;
        data["name"] = this.name;
        data["dietaryWishes"] = this.dietaryWishes;
        data["participantInfo"] = this.participantInfo ? this.participantInfo.toJSON() : <any>undefined;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_UserParams_ {
    email?: string;
    agreeToPrivacyPolicy?: boolean;
    partnerId?: number | undefined;
    name?: string;
    dietaryWishes?: string;
    participantInfo?: UpdateParticipantParams;
}

/** Make all properties in T optional */
export class Partial_PersonalUserParams_ implements IPartial_PersonalUserParams_ {
    name?: string;
    dietaryWishes?: string;
    participantInfo?: UpdateParticipantParams;

    constructor(data?: IPartial_PersonalUserParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.dietaryWishes = _data["dietaryWishes"];
            this.participantInfo = _data["participantInfo"] ? UpdateParticipantParams.fromJS(_data["participantInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Partial_PersonalUserParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_PersonalUserParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dietaryWishes"] = this.dietaryWishes;
        data["participantInfo"] = this.participantInfo ? this.participantInfo.toJSON() : <any>undefined;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_PersonalUserParams_ {
    name?: string;
    dietaryWishes?: string;
    participantInfo?: UpdateParticipantParams;
}

export class SendSetPasswordReminderParams implements ISendSetPasswordReminderParams {
    ids!: number[];
    date!: Date;

    constructor(data?: ISendSetPasswordReminderParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SendSetPasswordReminderParams {
        data = typeof data === 'object' ? data : {};
        let result = new SendSetPasswordReminderParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISendSetPasswordReminderParams {
    ids: number[];
    date: Date;
}

export class LoginParams implements ILoginParams {
    email!: string;
    password!: string;
    rememberMe?: boolean;

    constructor(data?: ILoginParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginParams {
        data = typeof data === 'object' ? data : {};
        let result = new LoginParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginParams {
    email: string;
    password: string;
    rememberMe?: boolean;
}

export class ParticipantInfo implements IParticipantInfo {
    studyProgram!: string;

    constructor(data?: IParticipantInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studyProgram = _data["studyProgram"];
        }
    }

    static fromJS(data: any): ParticipantInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studyProgram"] = this.studyProgram;
        return data;
    }
}

export interface IParticipantInfo {
    studyProgram: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}