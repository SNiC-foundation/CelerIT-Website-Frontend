//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/api";
    }

    /**
     * @return Ok
     */
    getAllActivities(): Promise<Activity[]> {
        let url_ = this.baseUrl + "/activity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllActivities(_response);
        });
    }

    protected processGetAllActivities(response: Response): Promise<Activity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Activity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity[]>(null as any);
    }

    /**
     * @param body Parameters to create activity with
     * @return Ok
     */
    createActivity(body: ActivityParams): Promise<Activity> {
        let url_ = this.baseUrl + "/activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateActivity(_response);
        });
    }

    protected processCreateActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Activity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }

    /**
     * @param id ID of activity to retrieve
     * @return Ok
     */
    getActivity(id: number): Promise<Activity> {
        let url_ = this.baseUrl + "/activity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivity(_response);
        });
    }

    protected processGetActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Activity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }

    /**
     * @param id ID of activity to update
     * @param body Update subset of parameter of activity
     * @return Ok
     */
    updateActivity(id: number, body: ActivityParams): Promise<Activity> {
        let url_ = this.baseUrl + "/activity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateActivity(_response);
        });
    }

    protected processUpdateActivity(response: Response): Promise<Activity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Activity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Activity>(null as any);
    }

    /**
     * @param id ID of the activity to delete
     * @return No content
     */
    deleteActivity(id: number): Promise<void> {
        let url_ = this.baseUrl + "/activity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteActivity(_response);
        });
    }

    protected processDeleteActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllParticipants(): Promise<Participant[]> {
        let url_ = this.baseUrl + "/participant";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllParticipants(_response);
        });
    }

    protected processGetAllParticipants(response: Response): Promise<Participant[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Participant.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Participant[]>(null as any);
    }

    /**
     * @param body Parameters to create participant with
     * @return Ok
     */
    createParticipant(body: CreateParticipantParams): Promise<Participant> {
        let url_ = this.baseUrl + "/participant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateParticipant(_response);
        });
    }

    protected processCreateParticipant(response: Response): Promise<Participant> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Participant.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Participant>(null as any);
    }

    /**
     * @param id ID of participant to retrieve
     * @return Ok
     */
    getParticipant(id: number): Promise<Participant> {
        let url_ = this.baseUrl + "/participant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetParticipant(_response);
        });
    }

    protected processGetParticipant(response: Response): Promise<Participant> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Participant.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Participant>(null as any);
    }

    /**
     * @param id ID of participant to update
     * @param body Update subset of parameter of participant
     * @return Ok
     */
    updateParticipant(id: number, body: Partial_UpdateParticipantParams_): Promise<Participant> {
        let url_ = this.baseUrl + "/participant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateParticipant(_response);
        });
    }

    protected processUpdateParticipant(response: Response): Promise<Participant> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Participant.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Participant>(null as any);
    }

    /**
     * @param id ID of the participant to delete
     * @return No content
     */
    deleteParticipant(id: number): Promise<void> {
        let url_ = this.baseUrl + "/participant/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteParticipant(_response);
        });
    }

    protected processDeleteParticipant(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllPartners(): Promise<Partner[]> {
        let url_ = this.baseUrl + "/partner";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPartners(_response);
        });
    }

    protected processGetAllPartners(response: Response): Promise<Partner[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Partner.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Partner[]>(null as any);
    }

    /**
     * @param body Parameters to create partner with
     * @return Ok
     */
    createPartner(body: PartnerParams): Promise<Partner> {
        let url_ = this.baseUrl + "/partner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePartner(_response);
        });
    }

    protected processCreatePartner(response: Response): Promise<Partner> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Partner.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Partner>(null as any);
    }

    /**
     * @param id ID of partner to retrieve
     * @return Ok
     */
    getPartner(id: number): Promise<Partner> {
        let url_ = this.baseUrl + "/partner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPartner(_response);
        });
    }

    protected processGetPartner(response: Response): Promise<Partner> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Partner.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Partner>(null as any);
    }

    /**
     * @param id ID of partner to update
     * @param body Update subset of parameter of partner
     * @return Ok
     */
    updatePartner(id: number, body: Partial_PartnerParams_): Promise<Partner> {
        let url_ = this.baseUrl + "/partner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePartner(_response);
        });
    }

    protected processUpdatePartner(response: Response): Promise<Partner> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Partner.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Partner>(null as any);
    }

    /**
     * @param id ID of the partner to delete
     * @return No content
     */
    deletePartner(id: number): Promise<void> {
        let url_ = this.baseUrl + "/partner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePartner(_response);
        });
    }

    protected processDeletePartner(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param logo (optional) 
     * @return No content
     */
    uploadPartnerLogo(id: number, logo: FileParameter | undefined): Promise<void> {
        let url_ = this.baseUrl + "/partner/{id}/logo";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (logo === null || logo === undefined)
            throw new Error("The parameter 'logo' cannot be null.");
        else
            content_.append("logo", logo.data, logo.fileName ? logo.fileName : "logo");

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadPartnerLogo(_response);
        });
    }

    protected processUploadPartnerLogo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllProgramParts(): Promise<ProgramPart[]> {
        let url_ = this.baseUrl + "/programpart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProgramParts(_response);
        });
    }

    protected processGetAllProgramParts(response: Response): Promise<ProgramPart[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgramPart.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramPart[]>(null as any);
    }

    /**
     * @param body Parameters to create programPart with
     * @return Ok
     */
    createProgramPart(body: ProgramPartParams): Promise<ProgramPart> {
        let url_ = this.baseUrl + "/programpart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProgramPart(_response);
        });
    }

    protected processCreateProgramPart(response: Response): Promise<ProgramPart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramPart.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramPart>(null as any);
    }

    /**
     * @param id ID of programPart to retrieve
     * @return Ok
     */
    getProgramPart(id: number): Promise<ProgramPart> {
        let url_ = this.baseUrl + "/programpart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProgramPart(_response);
        });
    }

    protected processGetProgramPart(response: Response): Promise<ProgramPart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramPart.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramPart>(null as any);
    }

    /**
     * @param id ID of programPart to update
     * @param body Update subset of parameter of programPart
     * @return Ok
     */
    updateProgramPart(id: number, body: Partial_ProgramPartParams_): Promise<ProgramPart> {
        let url_ = this.baseUrl + "/programpart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProgramPart(_response);
        });
    }

    protected processUpdateProgramPart(response: Response): Promise<ProgramPart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramPart.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramPart>(null as any);
    }

    /**
     * @param id ID of the programPart to delete
     * @return No content
     */
    deleteProgramPart(id: number): Promise<void> {
        let url_ = this.baseUrl + "/programpart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProgramPart(_response);
        });
    }

    protected processDeleteProgramPart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllRoles(): Promise<Role[]> {
        let url_ = this.baseUrl + "/role";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRoles(_response);
        });
    }

    protected processGetAllRoles(response: Response): Promise<Role[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role[]>(null as any);
    }

    /**
     * @param body Parameters to create role with
     * @return Ok
     */
    createRole(body: RoleParams): Promise<Role> {
        let url_ = this.baseUrl + "/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * @param id ID of role to retrieve
     * @return Ok
     */
    getRole(id: number): Promise<Role> {
        let url_ = this.baseUrl + "/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRole(_response);
        });
    }

    protected processGetRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * @param id ID of role to update
     * @param body Update subset of parameter of role
     * @return Ok
     */
    updateRole(id: number, body: Partial_RoleParams_): Promise<Role> {
        let url_ = this.baseUrl + "/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * @param id ID of the role to delete
     * @return No content
     */
    deleteRole(id: number): Promise<void> {
        let url_ = this.baseUrl + "/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    ping(): Promise<string> {
        let url_ = this.baseUrl + "/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPing(_response);
        });
    }

    protected processPing(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Ok
     */
    getAllSpeakers(): Promise<Speaker[]> {
        let url_ = this.baseUrl + "/speaker";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSpeakers(_response);
        });
    }

    protected processGetAllSpeakers(response: Response): Promise<Speaker[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Speaker.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Speaker[]>(null as any);
    }

    /**
     * @param body Parameters to create speaker with
     * @return Ok
     */
    createSpeaker(body: SpeakerParams): Promise<Speaker> {
        let url_ = this.baseUrl + "/speaker";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSpeaker(_response);
        });
    }

    protected processCreateSpeaker(response: Response): Promise<Speaker> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Speaker.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Speaker>(null as any);
    }

    /**
     * @param id ID of speaker to retrieve
     * @return Ok
     */
    getSpeaker(id: number): Promise<Speaker> {
        let url_ = this.baseUrl + "/speaker/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpeaker(_response);
        });
    }

    protected processGetSpeaker(response: Response): Promise<Speaker> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Speaker.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Speaker>(null as any);
    }

    /**
     * @param id ID of speaker to update
     * @param body Update subset of parameter of speaker
     * @return Ok
     */
    updateSpeaker(id: number, body: Partial_SpeakerParams_): Promise<Speaker> {
        let url_ = this.baseUrl + "/speaker/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSpeaker(_response);
        });
    }

    protected processUpdateSpeaker(response: Response): Promise<Speaker> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Speaker.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Speaker>(null as any);
    }

    /**
     * @param id ID of the speaker to delete
     * @return No content
     */
    deleteSpeaker(id: number): Promise<void> {
        let url_ = this.baseUrl + "/speaker/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSpeaker(_response);
        });
    }

    protected processDeleteSpeaker(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllSubscribeActivities(): Promise<SubscribeActivity[]> {
        let url_ = this.baseUrl + "/subscribeActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSubscribeActivities(_response);
        });
    }

    protected processGetAllSubscribeActivities(response: Response): Promise<SubscribeActivity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribeActivity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubscribeActivity[]>(null as any);
    }

    /**
     * @param body Parameters to create subscribeActivity with
     * @return Ok
     */
    createSubscribeActivity(body: CreateSubscribeActivityParams): Promise<SubscribeActivity> {
        let url_ = this.baseUrl + "/subscribeActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSubscribeActivity(_response);
        });
    }

    protected processCreateSubscribeActivity(response: Response): Promise<SubscribeActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscribeActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubscribeActivity>(null as any);
    }

    /**
     * @param id ID of subscribeActivity to retrieve
     * @return Ok
     */
    getSubscribeActivity(id: number): Promise<SubscribeActivity> {
        let url_ = this.baseUrl + "/subscribeActivity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSubscribeActivity(_response);
        });
    }

    protected processGetSubscribeActivity(response: Response): Promise<SubscribeActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscribeActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubscribeActivity>(null as any);
    }

    /**
     * @param id ID of subscribeActivity to update
     * @param body Update subset of parameter of subscribeActivity
     * @return Ok
     */
    updateSubscribeActivity(id: number, body: Partial_UpdateSubscribeActivityParams_): Promise<SubscribeActivity> {
        let url_ = this.baseUrl + "/subscribeActivity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSubscribeActivity(_response);
        });
    }

    protected processUpdateSubscribeActivity(response: Response): Promise<SubscribeActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscribeActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubscribeActivity>(null as any);
    }

    /**
     * @param id ID of the subscribeActivity to delete
     * @return No content
     */
    deleteSubscribeActivity(id: number): Promise<void> {
        let url_ = this.baseUrl + "/subscribeActivity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSubscribeActivity(_response);
        });
    }

    protected processDeleteSubscribeActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAllUsers(): Promise<User[]> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: Response): Promise<User[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User[]>(null as any);
    }

    /**
     * @param body Parameters to create user with
     * @return Ok
     */
    createUser(body: UserParams): Promise<User> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of user to retrieve
     * @return Ok
     */
    getUser(id: number): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of user to update
     * @param body Update subset of parameter of user
     * @return Ok
     */
    updateUser(id: number, body: Partial_UserParams_): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of the user to delete
     * @return No content
     */
    deleteUser(id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ProgramPart implements IProgramPart {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    name!: string;
    beginTime!: Date;
    endTime!: Date;

    constructor(data?: IProgramPart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProgramPart {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramPart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IProgramPart {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    name: string;
    beginTime: Date;
    endTime: Date;
}

export class Activity implements IActivity {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    name!: string;
    location!: string;
    programPartId!: number;
    programPart!: ProgramPart;
    description?: string;
    image?: string;
    speakerId?: number;
    speaker?: Speaker;
    subscribe?: SubscribeActivity;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.programPart = new ProgramPart();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.programPartId = _data["programPartId"];
            this.programPart = _data["programPart"] ? ProgramPart.fromJS(_data["programPart"]) : new ProgramPart();
            this.description = _data["description"];
            this.image = _data["image"];
            this.speakerId = _data["speakerId"];
            this.speaker = _data["speaker"] ? Speaker.fromJS(_data["speaker"]) : <any>undefined;
            this.subscribe = _data["subscribe"] ? SubscribeActivity.fromJS(_data["subscribe"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["location"] = this.location;
        data["programPartId"] = this.programPartId;
        data["programPart"] = this.programPart ? this.programPart.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["image"] = this.image;
        data["speakerId"] = this.speakerId;
        data["speaker"] = this.speaker ? this.speaker.toJSON() : <any>undefined;
        data["subscribe"] = this.subscribe ? this.subscribe.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActivity {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    name: string;
    location: string;
    programPartId: number;
    programPart: ProgramPart;
    description?: string;
    image?: string;
    speakerId?: number;
    speaker?: Speaker;
    subscribe?: SubscribeActivity;
}

export class Speaker implements ISpeaker {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    name!: string;
    description!: string;
    activities!: Activity[];
    imageFilename?: string;

    constructor(data?: ISpeaker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(Activity.fromJS(item));
            }
            this.imageFilename = _data["imageFilename"];
        }
    }

    static fromJS(data: any): Speaker {
        data = typeof data === 'object' ? data : {};
        let result = new Speaker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        data["imageFilename"] = this.imageFilename;
        return data;
    }
}

export interface ISpeaker {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    name: string;
    description: string;
    activities: Activity[];
    imageFilename?: string;
}

export class User implements IUser {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    email!: string;
    name!: string;
    dietaryWishes!: string;
    agreeToPrivacyPolicy!: boolean;
    participantInfo?: Participant;
    roles!: Role[];

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.dietaryWishes = _data["dietaryWishes"];
            this.agreeToPrivacyPolicy = _data["agreeToPrivacyPolicy"];
            this.participantInfo = _data["participantInfo"] ? Participant.fromJS(_data["participantInfo"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["email"] = this.email;
        data["name"] = this.name;
        data["dietaryWishes"] = this.dietaryWishes;
        data["agreeToPrivacyPolicy"] = this.agreeToPrivacyPolicy;
        data["participantInfo"] = this.participantInfo ? this.participantInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    email: string;
    name: string;
    dietaryWishes: string;
    agreeToPrivacyPolicy: boolean;
    participantInfo?: Participant;
    roles: Role[];
}

export class Participant implements IParticipant {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    userId!: number;
    user!: User;
    studyAssociation!: string;
    studyProgram!: string;
    agreeToSharingWithCompanies!: boolean;

    constructor(data?: IParticipant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.studyAssociation = _data["studyAssociation"];
            this.studyProgram = _data["studyProgram"];
            this.agreeToSharingWithCompanies = _data["agreeToSharingWithCompanies"];
        }
    }

    static fromJS(data: any): Participant {
        data = typeof data === 'object' ? data : {};
        let result = new Participant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["studyAssociation"] = this.studyAssociation;
        data["studyProgram"] = this.studyProgram;
        data["agreeToSharingWithCompanies"] = this.agreeToSharingWithCompanies;
        return data;
    }
}

export interface IParticipant {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    userId: number;
    user: User;
    studyAssociation: string;
    studyProgram: string;
    agreeToSharingWithCompanies: boolean;
}

export class Role implements IRole {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    name!: string;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        return data;
    }
}

export interface IRole {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    name: string;
}

export class SubscribeActivity implements ISubscribeActivity {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    activityId!: number;
    activity!: Activity;
    maxParticipants!: number;
    subscriptionListOpenDate!: Date;
    subscriptionListCloseDate!: Date;
    subscribers!: User[];

    constructor(data?: ISubscribeActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activity = new Activity();
            this.subscribers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : new Activity();
            this.maxParticipants = _data["maxParticipants"];
            this.subscriptionListOpenDate = _data["subscriptionListOpenDate"] ? new Date(_data["subscriptionListOpenDate"].toString()) : <any>undefined;
            this.subscriptionListCloseDate = _data["subscriptionListCloseDate"] ? new Date(_data["subscriptionListCloseDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["subscribers"])) {
                this.subscribers = [] as any;
                for (let item of _data["subscribers"])
                    this.subscribers!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscribeActivity {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribeActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["maxParticipants"] = this.maxParticipants;
        data["subscriptionListOpenDate"] = this.subscriptionListOpenDate ? this.subscriptionListOpenDate.toISOString() : <any>undefined;
        data["subscriptionListCloseDate"] = this.subscriptionListCloseDate ? this.subscriptionListCloseDate.toISOString() : <any>undefined;
        if (Array.isArray(this.subscribers)) {
            data["subscribers"] = [];
            for (let item of this.subscribers)
                data["subscribers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubscribeActivity {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    activityId: number;
    activity: Activity;
    maxParticipants: number;
    subscriptionListOpenDate: Date;
    subscriptionListCloseDate: Date;
    subscribers: User[];
}

export class UpdateSubscribeActivityParams implements IUpdateSubscribeActivityParams {
    maxParticipants!: number;
    subscriptionListOpenDate!: Date;
    subscriptionListCloseDate!: Date;

    constructor(data?: IUpdateSubscribeActivityParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxParticipants = _data["maxParticipants"];
            this.subscriptionListOpenDate = _data["subscriptionListOpenDate"] ? new Date(_data["subscriptionListOpenDate"].toString()) : <any>undefined;
            this.subscriptionListCloseDate = _data["subscriptionListCloseDate"] ? new Date(_data["subscriptionListCloseDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateSubscribeActivityParams {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubscribeActivityParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxParticipants"] = this.maxParticipants;
        data["subscriptionListOpenDate"] = this.subscriptionListOpenDate ? this.subscriptionListOpenDate.toISOString() : <any>undefined;
        data["subscriptionListCloseDate"] = this.subscriptionListCloseDate ? this.subscriptionListCloseDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateSubscribeActivityParams {
    maxParticipants: number;
    subscriptionListOpenDate: Date;
    subscriptionListCloseDate: Date;
}

export class ActivityParams implements IActivityParams {
    name!: string;
    location!: string;
    programPartId!: number;
    description?: string;
    image?: string;
    speakerId?: number;
    subscribe?: UpdateSubscribeActivityParams;

    constructor(data?: IActivityParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.programPartId = _data["programPartId"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.speakerId = _data["speakerId"];
            this.subscribe = _data["subscribe"] ? UpdateSubscribeActivityParams.fromJS(_data["subscribe"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityParams {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["programPartId"] = this.programPartId;
        data["description"] = this.description;
        data["image"] = this.image;
        data["speakerId"] = this.speakerId;
        data["subscribe"] = this.subscribe ? this.subscribe.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActivityParams {
    name: string;
    location: string;
    programPartId: number;
    description?: string;
    image?: string;
    speakerId?: number;
    subscribe?: UpdateSubscribeActivityParams;
}

export class CreateParticipantParams implements ICreateParticipantParams {
    studyAssociation!: string;
    studyProgram!: string;
    agreeToSharingWithCompanies!: boolean;
    userId!: number;

    constructor(data?: ICreateParticipantParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studyAssociation = _data["studyAssociation"];
            this.studyProgram = _data["studyProgram"];
            this.agreeToSharingWithCompanies = _data["agreeToSharingWithCompanies"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CreateParticipantParams {
        data = typeof data === 'object' ? data : {};
        let result = new CreateParticipantParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studyAssociation"] = this.studyAssociation;
        data["studyProgram"] = this.studyProgram;
        data["agreeToSharingWithCompanies"] = this.agreeToSharingWithCompanies;
        data["userId"] = this.userId;
        return data;
    }
}

export interface ICreateParticipantParams {
    studyAssociation: string;
    studyProgram: string;
    agreeToSharingWithCompanies: boolean;
    userId: number;
}

/** Make all properties in T optional */
export class Partial_UpdateParticipantParams_ implements IPartial_UpdateParticipantParams_ {
    studyAssociation?: string;
    studyProgram?: string;
    agreeToSharingWithCompanies?: boolean;

    constructor(data?: IPartial_UpdateParticipantParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studyAssociation = _data["studyAssociation"];
            this.studyProgram = _data["studyProgram"];
            this.agreeToSharingWithCompanies = _data["agreeToSharingWithCompanies"];
        }
    }

    static fromJS(data: any): Partial_UpdateParticipantParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_UpdateParticipantParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studyAssociation"] = this.studyAssociation;
        data["studyProgram"] = this.studyProgram;
        data["agreeToSharingWithCompanies"] = this.agreeToSharingWithCompanies;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_UpdateParticipantParams_ {
    studyAssociation?: string;
    studyProgram?: string;
    agreeToSharingWithCompanies?: boolean;
}

export enum SponsorPackage {
    Bronze = "bronze",
    Silver = "silver",
    Gold = "gold",
    Platinum = "platinum",
}

export class Partner implements IPartner {
    id!: number;
    createdAt!: Date;
    updatedAt!: Date;
    version!: number;
    name!: string;
    location!: string;
    specialization!: string;
    description!: string;
    url!: string;
    package!: SponsorPackage;
    logoFilename?: string;

    constructor(data?: IPartner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.specialization = _data["specialization"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.package = _data["package"];
            this.logoFilename = _data["logoFilename"];
        }
    }

    static fromJS(data: any): Partner {
        data = typeof data === 'object' ? data : {};
        let result = new Partner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["location"] = this.location;
        data["specialization"] = this.specialization;
        data["description"] = this.description;
        data["url"] = this.url;
        data["package"] = this.package;
        data["logoFilename"] = this.logoFilename;
        return data;
    }
}

export interface IPartner {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    version: number;
    name: string;
    location: string;
    specialization: string;
    description: string;
    url: string;
    package: SponsorPackage;
    logoFilename?: string;
}

export class PartnerParams implements IPartnerParams {
    name!: string;
    location!: string;
    specialization!: string;
    description!: string;
    url!: string;
    package!: SponsorPackage;

    constructor(data?: IPartnerParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.specialization = _data["specialization"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.package = _data["package"];
        }
    }

    static fromJS(data: any): PartnerParams {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["specialization"] = this.specialization;
        data["description"] = this.description;
        data["url"] = this.url;
        data["package"] = this.package;
        return data;
    }
}

export interface IPartnerParams {
    name: string;
    location: string;
    specialization: string;
    description: string;
    url: string;
    package: SponsorPackage;
}

/** Make all properties in T optional */
export class Partial_PartnerParams_ implements IPartial_PartnerParams_ {
    name?: string;
    location?: string;
    specialization?: string;
    description?: string;
    url?: string;
    package?: SponsorPackage;

    constructor(data?: IPartial_PartnerParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.specialization = _data["specialization"];
            this.description = _data["description"];
            this.url = _data["url"];
            this.package = _data["package"];
        }
    }

    static fromJS(data: any): Partial_PartnerParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_PartnerParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["specialization"] = this.specialization;
        data["description"] = this.description;
        data["url"] = this.url;
        data["package"] = this.package;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_PartnerParams_ {
    name?: string;
    location?: string;
    specialization?: string;
    description?: string;
    url?: string;
    package?: SponsorPackage;
}

export class ProgramPartParams implements IProgramPartParams {
    name!: string;
    beginTime!: Date;
    endTime!: Date;

    constructor(data?: IProgramPartParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProgramPartParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramPartParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IProgramPartParams {
    name: string;
    beginTime: Date;
    endTime: Date;
}

/** Make all properties in T optional */
export class Partial_ProgramPartParams_ implements IPartial_ProgramPartParams_ {
    name?: string;
    beginTime?: Date;
    endTime?: Date;

    constructor(data?: IPartial_ProgramPartParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Partial_ProgramPartParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ProgramPartParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_ProgramPartParams_ {
    name?: string;
    beginTime?: Date;
    endTime?: Date;
}

export class RoleParams implements IRoleParams {
    name!: string;

    constructor(data?: IRoleParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleParams {
        data = typeof data === 'object' ? data : {};
        let result = new RoleParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IRoleParams {
    name: string;
}

/** Make all properties in T optional */
export class Partial_RoleParams_ implements IPartial_RoleParams_ {
    name?: string;

    constructor(data?: IPartial_RoleParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Partial_RoleParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_RoleParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_RoleParams_ {
    name?: string;
}

export class SpeakerParams implements ISpeakerParams {
    name!: string;
    description!: string;

    constructor(data?: ISpeakerParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SpeakerParams {
        data = typeof data === 'object' ? data : {};
        let result = new SpeakerParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ISpeakerParams {
    name: string;
    description: string;
}

/** Make all properties in T optional */
export class Partial_SpeakerParams_ implements IPartial_SpeakerParams_ {
    name?: string;
    description?: string;

    constructor(data?: IPartial_SpeakerParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Partial_SpeakerParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_SpeakerParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_SpeakerParams_ {
    name?: string;
    description?: string;
}

export class CreateSubscribeActivityParams implements ICreateSubscribeActivityParams {
    maxParticipants!: number;
    subscriptionListOpenDate!: Date;
    subscriptionListCloseDate!: Date;
    activityId!: number;

    constructor(data?: ICreateSubscribeActivityParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxParticipants = _data["maxParticipants"];
            this.subscriptionListOpenDate = _data["subscriptionListOpenDate"] ? new Date(_data["subscriptionListOpenDate"].toString()) : <any>undefined;
            this.subscriptionListCloseDate = _data["subscriptionListCloseDate"] ? new Date(_data["subscriptionListCloseDate"].toString()) : <any>undefined;
            this.activityId = _data["activityId"];
        }
    }

    static fromJS(data: any): CreateSubscribeActivityParams {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubscribeActivityParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxParticipants"] = this.maxParticipants;
        data["subscriptionListOpenDate"] = this.subscriptionListOpenDate ? this.subscriptionListOpenDate.toISOString() : <any>undefined;
        data["subscriptionListCloseDate"] = this.subscriptionListCloseDate ? this.subscriptionListCloseDate.toISOString() : <any>undefined;
        data["activityId"] = this.activityId;
        return data;
    }
}

export interface ICreateSubscribeActivityParams {
    maxParticipants: number;
    subscriptionListOpenDate: Date;
    subscriptionListCloseDate: Date;
    activityId: number;
}

/** Make all properties in T optional */
export class Partial_UpdateSubscribeActivityParams_ implements IPartial_UpdateSubscribeActivityParams_ {
    maxParticipants?: number;
    subscriptionListOpenDate?: Date;
    subscriptionListCloseDate?: Date;

    constructor(data?: IPartial_UpdateSubscribeActivityParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxParticipants = _data["maxParticipants"];
            this.subscriptionListOpenDate = _data["subscriptionListOpenDate"] ? new Date(_data["subscriptionListOpenDate"].toString()) : <any>undefined;
            this.subscriptionListCloseDate = _data["subscriptionListCloseDate"] ? new Date(_data["subscriptionListCloseDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Partial_UpdateSubscribeActivityParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_UpdateSubscribeActivityParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxParticipants"] = this.maxParticipants;
        data["subscriptionListOpenDate"] = this.subscriptionListOpenDate ? this.subscriptionListOpenDate.toISOString() : <any>undefined;
        data["subscriptionListCloseDate"] = this.subscriptionListCloseDate ? this.subscriptionListCloseDate.toISOString() : <any>undefined;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_UpdateSubscribeActivityParams_ {
    maxParticipants?: number;
    subscriptionListOpenDate?: Date;
    subscriptionListCloseDate?: Date;
}

export class UpdateParticipantParams implements IUpdateParticipantParams {
    studyAssociation!: string;
    studyProgram!: string;
    agreeToSharingWithCompanies!: boolean;

    constructor(data?: IUpdateParticipantParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studyAssociation = _data["studyAssociation"];
            this.studyProgram = _data["studyProgram"];
            this.agreeToSharingWithCompanies = _data["agreeToSharingWithCompanies"];
        }
    }

    static fromJS(data: any): UpdateParticipantParams {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studyAssociation"] = this.studyAssociation;
        data["studyProgram"] = this.studyProgram;
        data["agreeToSharingWithCompanies"] = this.agreeToSharingWithCompanies;
        return data;
    }
}

export interface IUpdateParticipantParams {
    studyAssociation: string;
    studyProgram: string;
    agreeToSharingWithCompanies: boolean;
}

export class UserParams implements IUserParams {
    email!: string;
    name!: string;
    dietaryWishes!: string;
    agreeToPrivacyPolicy!: boolean;
    participantInfo?: UpdateParticipantParams;

    constructor(data?: IUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.dietaryWishes = _data["dietaryWishes"];
            this.agreeToPrivacyPolicy = _data["agreeToPrivacyPolicy"];
            this.participantInfo = _data["participantInfo"] ? UpdateParticipantParams.fromJS(_data["participantInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserParams {
        data = typeof data === 'object' ? data : {};
        let result = new UserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["dietaryWishes"] = this.dietaryWishes;
        data["agreeToPrivacyPolicy"] = this.agreeToPrivacyPolicy;
        data["participantInfo"] = this.participantInfo ? this.participantInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserParams {
    email: string;
    name: string;
    dietaryWishes: string;
    agreeToPrivacyPolicy: boolean;
    participantInfo?: UpdateParticipantParams;
}

/** Make all properties in T optional */
export class Partial_UserParams_ implements IPartial_UserParams_ {
    email?: string;
    name?: string;
    dietaryWishes?: string;
    agreeToPrivacyPolicy?: boolean;
    participantInfo?: UpdateParticipantParams;

    constructor(data?: IPartial_UserParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.dietaryWishes = _data["dietaryWishes"];
            this.agreeToPrivacyPolicy = _data["agreeToPrivacyPolicy"];
            this.participantInfo = _data["participantInfo"] ? UpdateParticipantParams.fromJS(_data["participantInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Partial_UserParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_UserParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["dietaryWishes"] = this.dietaryWishes;
        data["agreeToPrivacyPolicy"] = this.agreeToPrivacyPolicy;
        data["participantInfo"] = this.participantInfo ? this.participantInfo.toJSON() : <any>undefined;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_UserParams_ {
    email?: string;
    name?: string;
    dietaryWishes?: string;
    agreeToPrivacyPolicy?: boolean;
    participantInfo?: UpdateParticipantParams;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}